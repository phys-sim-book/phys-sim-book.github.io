<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GPU-Accelerated Simulation - Physics-Based Simulation</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Simulation with Optimization</li><li class="chapter-item expanded "><a href="lec1-discrete_space_time.html"><strong aria-hidden="true">1.</strong> Discrete Space and Time</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec1.1-solid_rep.html"><strong aria-hidden="true">1.1.</strong> Representations of a Solid Geometry</a></li><li class="chapter-item expanded "><a href="lec1.2-newton_2nd_law.html"><strong aria-hidden="true">1.2.</strong> Newton's Second Law</a></li><li class="chapter-item expanded "><a href="lec1.3-time_integration.html"><strong aria-hidden="true">1.3.</strong> Time Integration</a></li><li class="chapter-item expanded "><a href="lec1.4-explicit_time_integration.html"><strong aria-hidden="true">1.4.</strong> Explicit Time Integration</a></li><li class="chapter-item expanded "><a href="lec1.5-implicit_time_integration.html"><strong aria-hidden="true">1.5.</strong> Implicit Time integration</a></li><li class="chapter-item expanded "><a href="lec1.6-summary.html"><strong aria-hidden="true">1.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec2-opt_framework.html"><strong aria-hidden="true">2.</strong> Optimization Framework</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec2.1-opt_time_integration.html"><strong aria-hidden="true">2.1.</strong> Optimization Time Integrator</a></li><li class="chapter-item expanded "><a href="lec2.2-dirichlet_BC.html"><strong aria-hidden="true">2.2.</strong> Dirichlet Boundary Conditions</a></li><li class="chapter-item expanded "><a href="lec2.3-contact.html"><strong aria-hidden="true">2.3.</strong> Contact</a></li><li class="chapter-item expanded "><a href="lec2.4-friction.html"><strong aria-hidden="true">2.4.</strong> Friction</a></li><li class="chapter-item expanded "><a href="lec2.5-summary.html"><strong aria-hidden="true">2.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec3-projected_Newton.html"><strong aria-hidden="true">3.</strong> Projected Newton</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec3.1-conv_issue_Newton.html"><strong aria-hidden="true">3.1.</strong> Convergence of Newton's Method</a></li><li class="chapter-item expanded "><a href="lec3.2-line_search.html"><strong aria-hidden="true">3.2.</strong> Line Search</a></li><li class="chapter-item expanded "><a href="lec3.3-grad_based_opt.html"><strong aria-hidden="true">3.3.</strong> Gradient-Based Optimization</a></li><li class="chapter-item expanded "><a href="lec3.4-summary.html"><strong aria-hidden="true">3.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec4-2d_mass_spring.html"><strong aria-hidden="true">4.</strong> Case Study: 2D Mass-Spring*</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec4.1-discretizations.html"><strong aria-hidden="true">4.1.</strong> Spatial and Temporal Discretizations</a></li><li class="chapter-item expanded "><a href="lec4.2-inertia.html"><strong aria-hidden="true">4.2.</strong> Inertia Term</a></li><li class="chapter-item expanded "><a href="lec4.3-mass_spring_energy.html"><strong aria-hidden="true">4.3.</strong> Mass-Spring Potential Energy</a></li><li class="chapter-item expanded "><a href="lec4.4-opt_time_integrator.html"><strong aria-hidden="true">4.4.</strong> Optimization Time Integrator</a></li><li class="chapter-item expanded "><a href="lec4.5-sim_with_vis.html"><strong aria-hidden="true">4.5.</strong> Simulation with Visualization</a></li><li class="chapter-item expanded "><a href="lec4.6-gpu_accel.html" class="active"><strong aria-hidden="true">4.6.</strong> GPU-Accelerated Simulation</a></li><li class="chapter-item expanded "><a href="lec4.6-summary.html"><strong aria-hidden="true">4.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Boundary Treatments</li><li class="chapter-item expanded "><a href="lec5-dirichlet_BC_solve.html"><strong aria-hidden="true">5.</strong> Dirichlet Boundary Conditions*</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec5.1-equality_constraints.html"><strong aria-hidden="true">5.1.</strong> Equality Constraint Formulation</a></li><li class="chapter-item expanded "><a href="lec5.2-DOF_elimin.html"><strong aria-hidden="true">5.2.</strong> DOF Elimination Method</a></li><li class="chapter-item expanded "><a href="lec5.3-hanging_square.html"><strong aria-hidden="true">5.3.</strong> Case Study: Hanging Sqaure*</a></li><li class="chapter-item expanded "><a href="lec5.4-summary.html"><strong aria-hidden="true">5.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec6-slip_DBC.html"><strong aria-hidden="true">6.</strong> Slip Dirichlet Boundary Conditions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec6.1-axis_aligned.html"><strong aria-hidden="true">6.1.</strong> Axis-Aligned Slip DBC</a></li><li class="chapter-item expanded "><a href="lec6.2-change_of_vars.html"><strong aria-hidden="true">6.2.</strong> Change of Variables</a></li><li class="chapter-item expanded "><a href="lec6.3-general_slip_DBC.html"><strong aria-hidden="true">6.3.</strong> General Slip DBC</a></li><li class="chapter-item expanded "><a href="lec6.4-summary.html"><strong aria-hidden="true">6.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec7-dist_barrier.html"><strong aria-hidden="true">7.</strong> Distance Barrier for Nonpenetration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec7.1-signed_dists.html"><strong aria-hidden="true">7.1.</strong> Signed Distances</a></li><li class="chapter-item expanded "><a href="lec7.2-dist_barrier_formulation.html"><strong aria-hidden="true">7.2.</strong> Distance Barrier</a></li><li class="chapter-item expanded "><a href="lec7.3-sol_accuracy.html"><strong aria-hidden="true">7.3.</strong> Solution Accuracy</a></li><li class="chapter-item expanded "><a href="lec7.4-summary.html"><strong aria-hidden="true">7.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec8-filter_line_search.html"><strong aria-hidden="true">8.</strong> Filter Line Search*</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec8.1-tunneling.html"><strong aria-hidden="true">8.1.</strong> Tunneling Issue</a></li><li class="chapter-item expanded "><a href="lec8.2-nonpenetration_traj.html"><strong aria-hidden="true">8.2.</strong> Penetration-free Trajectory</a></li><li class="chapter-item expanded "><a href="lec8.3-square_drop.html"><strong aria-hidden="true">8.3.</strong> Case Study: Square Drop*</a></li><li class="chapter-item expanded "><a href="lec8.4-summary.html"><strong aria-hidden="true">8.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec9-friction.html"><strong aria-hidden="true">9.</strong> Frictional Contact</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec9.1-smooth_fric.html"><strong aria-hidden="true">9.1.</strong> Smooth Dynamic-Static Transition</a></li><li class="chapter-item expanded "><a href="lec9.2-semi_imp_fric.html"><strong aria-hidden="true">9.2.</strong> Semi-Implicit Discretization</a></li><li class="chapter-item expanded "><a href="lec9.3-fixed_point_iter.html"><strong aria-hidden="true">9.3.</strong> Fixed-Point Iteration</a></li><li class="chapter-item expanded "><a href="lec9.4-summary.html"><strong aria-hidden="true">9.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec10-square_on_slope.html"><strong aria-hidden="true">10.</strong> Case Study: Square On Slope*</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec10.1-ground_to_slope.html"><strong aria-hidden="true">10.1.</strong> From Ground To Slope</a></li><li class="chapter-item expanded "><a href="lec10.2-slope_fric.html"><strong aria-hidden="true">10.2.</strong> Slope Friction</a></li><li class="chapter-item expanded "><a href="lec10.3-summary.html"><strong aria-hidden="true">10.3.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec11-mov_DBC.html"><strong aria-hidden="true">11.</strong> Moving Boundary Conditions*</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec11.1-penalty_method.html"><strong aria-hidden="true">11.1.</strong> Penalty Method</a></li><li class="chapter-item expanded "><a href="lec11.2-compress_square.html"><strong aria-hidden="true">11.2.</strong> Case Study: Compressing Square*</a></li><li class="chapter-item expanded "><a href="lec11.3-summary.html"><strong aria-hidden="true">11.3.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Hyperelasticity</li><li class="chapter-item expanded "><a href="lec12-kinematics.html"><strong aria-hidden="true">12.</strong> Kinematics Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec12.1-continuum_motion.html"><strong aria-hidden="true">12.1.</strong> Continuum Motion</a></li><li class="chapter-item expanded "><a href="lec12.2-deformation.html"><strong aria-hidden="true">12.2.</strong> Deformation</a></li><li class="chapter-item expanded "><a href="lec12.3-summary.html"><strong aria-hidden="true">12.3.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec13-strain_energy.html"><strong aria-hidden="true">13.</strong> Strain Energy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec13.1-rigid_null_rot_inv.html"><strong aria-hidden="true">13.1.</strong> Rigid Null Space and Rotation Invariance</a></li><li class="chapter-item expanded "><a href="lec13.2-polar_svd.html"><strong aria-hidden="true">13.2.</strong> Polar Singular Value Decomposition</a></li><li class="chapter-item expanded "><a href="lec13.3-simp_model_inversion.html"><strong aria-hidden="true">13.3.</strong> Simplified Models and Invertibility</a></li><li class="chapter-item expanded "><a href="lec13.4-summary.html"><strong aria-hidden="true">13.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec14-stress_and_derivatives.html"><strong aria-hidden="true">14.</strong> Stress and Its Derivatives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec14.1-stress.html"><strong aria-hidden="true">14.1.</strong> Stress</a></li><li class="chapter-item expanded "><a href="lec14.2-compute_P.html"><strong aria-hidden="true">14.2.</strong> Computing Stress</a></li><li class="chapter-item expanded "><a href="lec14.3-compute_stress_deriv.html"><strong aria-hidden="true">14.3.</strong> Computing Stress Derivatives</a></li><li class="chapter-item expanded "><a href="lec14.4-summary.html"><strong aria-hidden="true">14.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec15-inv_free_elasticity.html"><strong aria-hidden="true">15.</strong> Case Study: Inversion-free Elasticity*</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec15.1-linear_tri_elem.html"><strong aria-hidden="true">15.1.</strong> Linear Triangle Elements</a></li><li class="chapter-item expanded "><a href="lec15.2-energy_grad_hess.html"><strong aria-hidden="true">15.2.</strong> Computing Energy, Gradient, and Hessian</a></li><li class="chapter-item expanded "><a href="lec15.3-filter_line_search.html"><strong aria-hidden="true">15.3.</strong> Filter Line Search for Non-Inversion</a></li><li class="chapter-item expanded "><a href="lec15.4-summary.html"><strong aria-hidden="true">15.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Governing Equations</li><li class="chapter-item expanded "><a href="lec16-strong_and_weak_forms.html"><strong aria-hidden="true">16.</strong> Strong and Weak Forms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec16.1-mass_conserv.html"><strong aria-hidden="true">16.1.</strong> Conservation of Mass</a></li><li class="chapter-item expanded "><a href="lec16.2-momentum_conserv.html"><strong aria-hidden="true">16.2.</strong> Conservation of Momentum</a></li><li class="chapter-item expanded "><a href="lec16.3-weak_form.html"><strong aria-hidden="true">16.3.</strong> Weak Form</a></li><li class="chapter-item expanded "><a href="lec16.4-summary.html"><strong aria-hidden="true">16.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec17-disc_weak_form.html"><strong aria-hidden="true">17.</strong> Discretization of Weak Forms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec17.1-discrete_space.html"><strong aria-hidden="true">17.1.</strong> Discrete Space</a></li><li class="chapter-item expanded "><a href="lec17.2-discrete_time.html"><strong aria-hidden="true">17.2.</strong> Discrete Time</a></li><li class="chapter-item expanded "><a href="lec17.3-summary.html"><strong aria-hidden="true">17.3.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec18-BC_and_fric.html"><strong aria-hidden="true">18.</strong> Boundary Conditions and Frictional Contact</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec18.1-incorporate_BC.html"><strong aria-hidden="true">18.1.</strong> Incorporating Boundary Conditions</a></li><li class="chapter-item expanded "><a href="lec18.2-normal_contact.html"><strong aria-hidden="true">18.2.</strong> Normal Contact for Nonpenetration</a></li><li class="chapter-item expanded "><a href="lec18.3-barrier_potential.html"><strong aria-hidden="true">18.3.</strong> Barrier Potential</a></li><li class="chapter-item expanded "><a href="lec18.4-friction_force.html"><strong aria-hidden="true">18.4.</strong> Friction Force</a></li><li class="chapter-item expanded "><a href="lec18.5-summary.html"><strong aria-hidden="true">18.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Finite Element Method</li><li class="chapter-item expanded "><a href="lec19-linear_FEM.html"><strong aria-hidden="true">19.</strong> Linear Finite Elements</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec19.1-linear_disp_field.html"><strong aria-hidden="true">19.1.</strong> Piecewise Linear Displacement Field</a></li><li class="chapter-item expanded "><a href="lec19.2-mass_matrix.html"><strong aria-hidden="true">19.2.</strong> Mass Matrix and Lumping</a></li><li class="chapter-item expanded "><a href="lec19.3-elasticity_term.html"><strong aria-hidden="true">19.3.</strong> Elasticity Term</a></li><li class="chapter-item expanded "><a href="lec19.4-summary.html"><strong aria-hidden="true">19.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec20-pw_linear_boundary.html"><strong aria-hidden="true">20.</strong> Piecewise Linear Boundaries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec20.1-boundary_conditions.html"><strong aria-hidden="true">20.1.</strong> Boundary Conditions</a></li><li class="chapter-item expanded "><a href="lec20.2-obstacle_contact.html"><strong aria-hidden="true">20.2.</strong> Solid-Obstacle Contact</a></li><li class="chapter-item expanded "><a href="lec20.3-self_contact.html"><strong aria-hidden="true">20.3.</strong> Self-Contact</a></li><li class="chapter-item expanded "><a href="lec20.4-summary.html"><strong aria-hidden="true">20.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec21-2d_self_contact.html"><strong aria-hidden="true">21.</strong> Case Study: 2D Self-Contact*</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec21.1-scene_setup.html"><strong aria-hidden="true">21.1.</strong> Scene Setup and Boundary Element Collection</a></li><li class="chapter-item expanded "><a href="lec21.2-point_edge_dist.html"><strong aria-hidden="true">21.2.</strong> Point-Edge Distance</a></li><li class="chapter-item expanded "><a href="lec21.3-barrier_and_derivatives.html"><strong aria-hidden="true">21.3.</strong> Barrier Energy and Its Derivatives</a></li><li class="chapter-item expanded "><a href="lec21.4-ccd.html"><strong aria-hidden="true">21.4.</strong> Continuous Collision Detection</a></li><li class="chapter-item expanded "><a href="lec21.5-summary.html"><strong aria-hidden="true">21.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec22-2d_self_fric.html"><strong aria-hidden="true">22.</strong> 2D Frictional Self-Contact*</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec22.1-disc_and_approx.html"><strong aria-hidden="true">22.1.</strong> Discretization and Approximation</a></li><li class="chapter-item expanded "><a href="lec22.2-precompute.html"><strong aria-hidden="true">22.2.</strong> Precomputing Normal and Tangent Information</a></li><li class="chapter-item expanded "><a href="lec22.3-fric_and_derivatives.html"><strong aria-hidden="true">22.3.</strong> Friction Energy and Its Derivatives</a></li><li class="chapter-item expanded "><a href="lec22.4-summary.html"><strong aria-hidden="true">22.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec23-3d_elastodynamics.html"><strong aria-hidden="true">23.</strong> 3D Elastodynamics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec23.1-kinematics.html"><strong aria-hidden="true">23.1.</strong> Kinematics</a></li><li class="chapter-item expanded "><a href="lec23.2-mass_matrix.html"><strong aria-hidden="true">23.2.</strong> Mass Matrix</a></li><li class="chapter-item expanded "><a href="lec23.3-elasticity.html"><strong aria-hidden="true">23.3.</strong> Elasticity</a></li><li class="chapter-item expanded "><a href="lec23.4-summary.html"><strong aria-hidden="true">23.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec24-3d_fric_self_contact.html"><strong aria-hidden="true">24.</strong> 3D Frictional Self-Contact</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec24.1-barrier_and_dist.html"><strong aria-hidden="true">24.1.</strong> Barrier and Distances</a></li><li class="chapter-item expanded "><a href="lec24.2-collision_detection.html"><strong aria-hidden="true">24.2.</strong> Collision Detection</a></li><li class="chapter-item expanded "><a href="lec24.3-friction.html"><strong aria-hidden="true">24.3.</strong> Friction</a></li><li class="chapter-item expanded "><a href="lec24.4-summary.html"><strong aria-hidden="true">24.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Spatial Reductions</li><li class="chapter-item expanded "><a href="lec25-rigid_body_sim.html"><strong aria-hidden="true">25.</strong> Rigid Body Simulation*</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec25.1-rigid_body_dynamics.html"><strong aria-hidden="true">25.1.</strong> Rigid Body Dynamics</a></li><li class="chapter-item expanded "><a href="lec25.2-subspace_sim.html"><strong aria-hidden="true">25.2.</strong> Subspace Simulation</a></li><li class="chapter-item expanded "><a href="lec25.3-affine_body_dynamics.html"><strong aria-hidden="true">25.3.</strong> Affine Body Dynamics</a></li><li class="chapter-item expanded "><a href="lec25.4-dropping_block.html"><strong aria-hidden="true">25.4.</strong> Case Study: ABD Square Drop*</a></li><li class="chapter-item expanded "><a href="lec25.5-summary.html"><strong aria-hidden="true">25.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec25.6-modal_reductions.html"><strong aria-hidden="true">26.</strong> Modal Reductions*</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec25.7-linear_modal_analysis.html"><strong aria-hidden="true">26.1.</strong> Linear Modal Analysis</a></li><li class="chapter-item expanded "><a href="lec25.7.2-linear_demo.html"><strong aria-hidden="true">26.2.</strong> Linear Demo*</a></li><li class="chapter-item expanded "><a href="lec25.8-nonlinear_reductions.html"><strong aria-hidden="true">26.3.</strong> Non-linear Reductions</a></li><li class="chapter-item expanded "><a href="lec25.9-basis_choice.html"><strong aria-hidden="true">26.4.</strong> Reduction Basis</a></li><li class="chapter-item expanded "><a href="lec25.10-summary.html"><strong aria-hidden="true">26.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Material Point Method</li><li class="chapter-item expanded "><a href="lec26-mpm_disc.html"><strong aria-hidden="true">27.</strong> Spatial and Temporal Discretization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec26.1-material_particles.html"><strong aria-hidden="true">27.1.</strong> Material Particles</a></li><li class="chapter-item expanded "><a href="lec26.2-interpolating_functions.html"><strong aria-hidden="true">27.2.</strong> Interpolating Functions</a></li><li class="chapter-item expanded "><a href="lec26.3-euler_lag_transfers.html"><strong aria-hidden="true">27.3.</strong> Particle-Grid Transfers</a></li><li class="chapter-item expanded "><a href="lec26.4-particle_state_update.html"><strong aria-hidden="true">27.4.</strong> Deformation Gradient and Particle State Update</a></li><li class="chapter-item expanded "><a href="lec26.5-summary.html"><strong aria-hidden="true">27.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec27-mpm_plasticity.html"><strong aria-hidden="true">28.</strong> Beyond Elasticity: Plasticity and Viscosity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec27.1-disc_plastic_flow.html"><strong aria-hidden="true">28.1.</strong> Discretization of Plastic Flow</a></li><li class="chapter-item expanded "><a href="lec27.2-yield_criterion.html"><strong aria-hidden="true">28.2.</strong> Yield Condition and Return Mapping</a></li><li class="chapter-item expanded "><a href="lec27.3-summary.html"><strong aria-hidden="true">28.3.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec28-mpm_bc.html"><strong aria-hidden="true">29.</strong> Boundary Treatments</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec28.1-grid_bc.html"><strong aria-hidden="true">29.1.</strong> Boundary Conditions</a></li><li class="chapter-item expanded "><a href="lec28.2-contact_on_particles.html"><strong aria-hidden="true">29.2.</strong> Frictional Contact on Material Particles</a></li><li class="chapter-item expanded "><a href="lec28.3-summary.html"><strong aria-hidden="true">29.3.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec29-mpm_elastic_case_study.html"><strong aria-hidden="true">30.</strong> Case Study: Two Colliding Elastic Blocks in 2D*</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec29.1-simulation_setup.html"><strong aria-hidden="true">30.1.</strong> Simulation Setup</a></li><li class="chapter-item expanded "><a href="lec29.2-pic_transfer.html"><strong aria-hidden="true">30.2.</strong> Particle-In-Cell Transfer</a></li><li class="chapter-item expanded "><a href="lec29.3-summary.html"><strong aria-hidden="true">30.3.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec30-mpm_sand_case_study.html"><strong aria-hidden="true">31.</strong> Case Study: 2D Sand with a Sphere Collider*</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec30.1-drucker_prager.html"><strong aria-hidden="true">31.1.</strong> Drucker-Prager Elastoplasticity</a></li><li class="chapter-item expanded "><a href="lec30.2-sphere_sdf.html"><strong aria-hidden="true">31.2.</strong> SDF-based Sphere Collider</a></li><li class="chapter-item expanded "><a href="lec30.3-apic_transfer.html"><strong aria-hidden="true">31.3.</strong> Affine Particle-In-Cell Transfer</a></li><li class="chapter-item expanded "><a href="lec30.4-summary.html"><strong aria-hidden="true">31.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Position Based Simulations</li><li class="chapter-item expanded "><a href="lec31-position_based_dynamics.html"><strong aria-hidden="true">32.</strong> Position Based Dynamics (PBD)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec31.1-pbd_preliminaries.html"><strong aria-hidden="true">32.1.</strong> Particle Simulation Preliminaries</a></li><li class="chapter-item expanded "><a href="lec31.2-core_framework.html"><strong aria-hidden="true">32.2.</strong> Core Algorithm / Position Based Framework</a></li><li class="chapter-item expanded "><a href="lec31.3-formulation.html"><strong aria-hidden="true">32.3.</strong> Constraint Formulation</a></li><li class="chapter-item expanded "><a href="lec31.4-solver.html"><strong aria-hidden="true">32.4.</strong> Constraint Solver</a></li><li class="chapter-item expanded "><a href="lec31.5-stiffness_damping.html"><strong aria-hidden="true">32.5.</strong> Stiffness and Damping</a></li><li class="chapter-item expanded "><a href="lec31.6-summary.html"><strong aria-hidden="true">32.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="lec32-pbd_constraint_types.html"><strong aria-hidden="true">33.</strong> PBD Constraint Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec32.1-pbd_cloth_constraints.html"><strong aria-hidden="true">33.1.</strong> Cloth: Stretching and Bending</a></li><li class="chapter-item expanded "><a href="lec32.2-pbd_collisions_constraints.html"><strong aria-hidden="true">33.2.</strong> Collision Constraints</a></li><li class="chapter-item expanded "><a href="lec32.3-pbd_volume_constraints.html"><strong aria-hidden="true">33.3.</strong> Volume Conservation Constraints</a></li><li class="chapter-item expanded "><a href="lec32.4-position_based_fluids.html"><strong aria-hidden="true">33.4.</strong> Position Based Fluids: Density and Surface Constraints</a></li><li class="chapter-item expanded "><a href="lec32.5-pbd_continuum.html"><strong aria-hidden="true">33.5.</strong> Continuum-based Constraints</a></li><li class="chapter-item expanded "><a href="lec32-summary.html"><strong aria-hidden="true">33.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Special Topics</li><li class="chapter-item expanded "><a href="lec33-linear_sys.html"><strong aria-hidden="true">34.</strong> Linear System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lec33.1-direct_solver.html"><strong aria-hidden="true">34.1.</strong> Direct Solver</a></li><li class="chapter-item expanded "><a href="lec33.2-basic_iterative_methods.html"><strong aria-hidden="true">34.2.</strong> Basic Iterative Methods</a></li><li class="chapter-item expanded "><a href="lec33.3-conjugate_gradient.html"><strong aria-hidden="true">34.3.</strong> Conjugate Gradient</a></li><li class="chapter-item expanded "><a href="lec33.4-summary.html"><strong aria-hidden="true">34.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="bibliography.html">Bibliography</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Physics-Based Simulation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="gpu-accelerated-simulation"><a class="header" href="#gpu-accelerated-simulation">GPU-Accelerated Simulation</a></h2>
<p>*<em>Author of this section: <a href="https://roushelfy.github.io/">Zhaofeng Luo</a>, Carnegie Mellon University</em></p>
<p>We now rewrite the 2D mass-spring simulator to leverage GPU acceleration.
Instead of directly writing <a href="https://developer.nvidia.com/cuda-toolkit">CUDA</a>, we resort to <a href="https://github.com/MuGdxy/muda">MUDA</a>, a lightweight library that provides a simple interface for GPU-accelerated computations.</p>
<p>The architecture of the GPU-accelerated simulator is similar to the Python version. All function and variable names are consistent with the Numpy version. However, the implementation details are different due to the GPU architecture and programming model. Before delving into the details, let's first get a feeling of the speedup that GPU could bring us from the following gif (<a href="#fig:lec4:cpu_vs_gpu">Figure 4.6.1</a>).</p>
<figure>
    <center>
    <img src="img/lec4/cpu_gif.gif">
    <img src="img/lec4/gpu_gif.gif">
    </center>
    <figcaption><b><a name="fig:lec4:cpu_vs_gpu"></a>
Figure 4.6.1.</b> An illustration of simulation speed of the Numpy CPU (left) and the MUDA GPU (right) versions.</figcaption>
</figure>
<h3 id="key-considerations-for-gpu-programming"><a class="header" href="#key-considerations-for-gpu-programming">Key Considerations for GPU Programming</a></h3>
<p>To maximize resource utilization on the GPU, there are two important aspects to consider:</p>
<ul>
<li><strong>Minimizing Data Transfer.</strong> In most modern architectures, CPU and GPU have separate memory spaces. Transferring data between these spaces can be expensive. Therefore, it is essential to minimize data transfers between CPU and GPU.</li>
<li><strong>Exploiting Parallelism.</strong> GPUs excel at parallel computations. However, care must be taken to avoid read-write conflicts that can arise when multiple threads attempt to access the same memory locations simultaneously.</li>
</ul>
<h3 id="minimizing-data-transfer"><a class="header" href="#minimizing-data-transfer">Minimizing Data Transfer</a></h3>
<p>To reduce data transfer between the CPU and GPU, we store the main energy values and their derivatives on the GPU. Computations are then performed directly on the GPU, and only the necessary position information is transferred back to the CPU for control and rendering. A more efficient implementation could render directly on the GPU, eliminating even this data transfer, but for simplicity and readability, we have not implemented that here.</p>
<p>To make the code more readable, the variables begin with <code>device_</code> are stored in the GPU memory, and the variables begin with <code>host_</code> are stored in the CPU memory.</p>
<p><a name="imp:lec4:energy_definition"></a>
<strong>Implementation 4.6.1 (Data structure, MassSpringEnergy.cu).</strong></p>
<pre><code class="language-cpp">template &lt;typename T, int dim&gt;
struct MassSpringEnergy&lt;T, dim&gt;::Impl
{
	DeviceBuffer&lt;T&gt; device_x;
	DeviceBuffer&lt;T&gt; device_l2, device_k;
	DeviceBuffer&lt;int&gt; device_e;
	int N;
	DeviceBuffer&lt;T&gt; device_grad;
	DeviceTripletMatrix&lt;T, 1&gt; device_hess;
};
</code></pre>
<p>As shown in the code above, the energy values and their derivatives, as well as all the necessary parameters are stored in a <code>DeviceBuffer</code> object, which is a wrapper of the CUDA device memory implemented by the MUDA library. This allows us to perform computations directly on the GPU without the need for data transfer between the CPU and GPU.</p>
<h3 id="newtons-method"><a class="header" href="#newtons-method">Newton's Method</a></h3>
<p>The iterations of Newton's method is a serial process and cannot be parallelized. Therefore, we implement this part on the CPU:</p>
<p><a name="imp:lec4:gpu_time_integrator"></a>
<strong>Implementation 4.6.2 (Newton's method, simulator.cu).</strong></p>
<pre><code class="language-cpp">template &lt;typename T, int dim&gt;
void MassSpringSimulator&lt;T, dim&gt;::Impl::step_forward()
{
    update_x_tilde(add_vector&lt;T&gt;(device_x, device_v, 1, h));
    DeviceBuffer&lt;T&gt; device_x_n = device_x; // Copy current positions to device_x_n
    int iter = 0;
    T E_last = IP_val();
    DeviceBuffer&lt;T&gt; device_p = search_direction();
    T residual = max_vector(device_p) / h;
    while (residual &gt; tol)
    {
        std::cout &lt;&lt; "Iteration " &lt;&lt; iter &lt;&lt; " residual " &lt;&lt; residual &lt;&lt; "E_last" &lt;&lt; E_last &lt;&lt; "\n";
        // Line search
        T alpha = 1;
        DeviceBuffer&lt;T&gt; device_x0 = device_x;
        update_x(add_vector&lt;T&gt;(device_x0, device_p, 1.0, alpha));
        while (IP_val() &gt; E_last)
        {
            alpha /= 2;
            update_x(add_vector&lt;T&gt;(device_x0, device_p, 1.0, alpha));
        }
        std::cout &lt;&lt; "step size = " &lt;&lt; alpha &lt;&lt; "\n";
        E_last = IP_val();
        device_p = search_direction();
        residual = max_vector(device_p) / h;
        iter += 1;
    }
    update_v(add_vector&lt;T&gt;(device_x, device_x_n, 1 / h, -1 / h));
}
</code></pre>
<p>In this function, <code>step_forward</code>, the projected Newton method with line search is implemented, performing necessary computations on the GPU while controlling the process on the CPU.
Any variable begin with <code>device_</code> here is a <code>DeviceBuffer</code> object on the GPU. To print the values in <code>DeviceBuffer</code> for debugging purposes, the common practice is to transfer the data back to the CPU, or call the <code>display_vec</code> function (which calls <code>printf</code> in parallel on the GPU) implemented in <code>uti.cu</code>.</p>
<p>The <code>update_x</code> function updates the positions of the nodes to all Energy classes and transfers the updated positions back to the CPU for rendering:</p>
<p><a name="imp:lec4:gpu_update_x"></a>
<strong>Implementation 4.6.3 (Update positions, simulator.cu).</strong></p>
<pre><code class="language-cpp">template &lt;typename T, int dim&gt;
void MassSpringSimulator&lt;T, dim&gt;::Impl::update_x(const DeviceBuffer&lt;T&gt; &amp;new_x)
{
    inertialenergy.update_x(new_x);
    massspringenergy.update_x(new_x);
    device_x = new_x;
}
</code></pre>
<p>As the Energy classes has already updated its positions, the <code>IP_val</code> function no loner needs to pass any parameters, avoiding unnecessary data transfer.
In fact, it only calls the <code>val</code> function of all energy classes and then sum the results together:</p>
<p><a name="imp:lec4:gpu_ip_val"></a>
<strong>Implementation 4.6.4 (Computing IP, simulator.cu).</strong></p>
<pre><code class="language-cpp">template &lt;typename T, int dim&gt;
T MassSpringSimulator&lt;T, dim&gt;::Impl::IP_val()
{

    return inertialenergy.val() + massspringenergy.val() * h * h;
}
</code></pre>
<p>Similarly for the <code>IP_grad</code> and <code>IP_hess</code> functions:</p>
<p><a name="imp:lec4:gpu_ip_grad_hess"></a>
<strong>Implementation 4.6.5 (Computing IP gradient and Hessian, simulator.cu).</strong></p>
<pre><code class="language-cpp">template &lt;typename T, int dim&gt;
DeviceBuffer&lt;T&gt; MassSpringSimulator&lt;T, dim&gt;::Impl::IP_grad()
{
    return add_vector&lt;T&gt;(inertialenergy.grad(), massspringenergy.grad(), 1.0, h * h);
}

template &lt;typename T, int dim&gt;
DeviceTripletMatrix&lt;T, 1&gt; MassSpringSimulator&lt;T, dim&gt;::Impl::IP_hess()
{
    DeviceTripletMatrix&lt;T, 1&gt; inertial_hess = inertialenergy.hess();
    DeviceTripletMatrix&lt;T, 1&gt; massspring_hess = massspringenergy.hess();
    DeviceTripletMatrix&lt;T, 1&gt; hess = add_triplet&lt;T&gt;(inertial_hess, massspring_hess, 1.0, h * h);
    return hess;
}
</code></pre>
<p>Notice that they utilize the parallel operations (<code>add_vector</code> and <code>add_triplet</code>, which are implemented in <code>uti.cu</code>) on the GPU to perform the summation for gradients and Hessians.</p>
<h3 id="parallel-computations"><a class="header" href="#parallel-computations">Parallel Computations</a></h3>
<p>In our implementation, parallel computation is primarily employed in the computation of energy and its derivatives, as well as vector addition and subtraction. Let's take the MassSpringEnergy computation as an example.</p>
<h4 id="energy-computation"><a class="header" href="#energy-computation">Energy Computation</a></h4>
<p><a name="imp:lec4:MassSpringEnergyVal"></a>
<strong>Implementation 4.6.6 (Computing energy, MassSpringEnergy.cu).</strong></p>
<pre><code class="language-cpp">template &lt;typename T, int dim&gt;
T MassSpringEnergy&lt;T, dim&gt;::val()
{
	auto &amp;device_x = pimpl_-&gt;device_x;
	auto &amp;device_e = pimpl_-&gt;device_e;
	auto &amp;device_l2 = pimpl_-&gt;device_l2;
	auto &amp;device_k = pimpl_-&gt;device_k;
	int N = device_e.size() / 2;
	DeviceBuffer&lt;T&gt; device_val(N);
	ParallelFor(256).apply(N, [device_val = device_val.viewer(), device_x = device_x.cviewer(), device_e = device_e.cviewer(), device_l2 = device_l2.cviewer(), device_k = device_k.cviewer()] __device__(int i) mutable
						   {
		int idx1= device_e(2 * i); // First node index
		int idx2 = device_e(2 * i + 1); // Second node index
		T diff = 0;
		for (int d = 0; d &lt; dim;d++){
			T diffi = device_x(dim * idx1 + d) - device_x(dim * idx2 + d);
			diff += diffi * diffi;
		}
		device_val(i) = 0.5 * device_l2(i) * device_k(i) * (diff / device_l2(i) - 1) * (diff / device_l2(i) - 1); })
		.wait();

	return devicesum(device_val);
} // Calculate the energy
</code></pre>
<p>The <code>ParallelFor</code> function distributes the computation across multiple GPU threads. The captured variables in the lambda function allow access to the necessary data structures within each thread.</p>
<h4 id="gradient-computation"><a class="header" href="#gradient-computation">Gradient Computation</a></h4>
<p><a name="imp:lec4:MassSpringEnergyGrad"></a>
<strong>Implementation 4.6.7 (Computing gradients, MassSpringEnergy.cu).</strong></p>
<pre><code class="language-cpp">template &lt;typename T, int dim&gt;
const DeviceBuffer&lt;T&gt; &amp;MassSpringEnergy&lt;T, dim&gt;::grad()
{
	auto &amp;device_x = pimpl_-&gt;device_x;
	auto &amp;device_e = pimpl_-&gt;device_e;
	auto &amp;device_l2 = pimpl_-&gt;device_l2;
	auto &amp;device_k = pimpl_-&gt;device_k;
	auto N = pimpl_-&gt;device_e.size() / 2;
	auto &amp;device_grad = pimpl_-&gt;device_grad;
	device_grad.fill(0);
	ParallelFor(256).apply(N, [device_x = device_x.cviewer(), device_e = device_e.cviewer(), device_l2 = device_l2.cviewer(), device_k = device_k.cviewer(), device_grad = device_grad.viewer()] __device__(int i) mutable
						   {
		int idx1= device_e(2 * i); // First node index
		int idx2 = device_e(2 * i + 1); // Second node index
		T diff = 0;
		T diffi[dim];
		for (int d = 0; d &lt; dim;d++){
			diffi[d] = device_x(dim * idx1 + d) - device_x(dim * idx2 + d);
			diff += diffi[d] * diffi[d];
		}
		T factor = 2 * device_k(i) * (diff / device_l2(i) -1);
		for(int d=0;d&lt;dim;d++){
		   atomicAdd(&amp;device_grad(dim * idx1 + d), factor * diffi[d]);
		   atomicAdd(&amp;device_grad(dim * idx2 + d), -factor * diffi[d]);	  
		} })
		.wait();
	// display_vec(device_grad);
	return device_grad;
}
</code></pre>
<p>The <code>atomicAdd</code> function is crucial in the gradient computation to ensure safe concurrent updates to shared data (different edges can update the gradient of the same node), thus preventing race conditions.</p>
<h4 id="hessian-computation"><a class="header" href="#hessian-computation">Hessian Computation</a></h4>
<p>We utilized the Sparse Matrix data structure to store the Hessian matrix. The computation is parallelized across multiple threads, with each thread updating a specific element of the Hessian matrix. The actual size of the Sparse Matrix is calculated at the start of the simulation, allocating just enough memory for non-zero entries. The main consideration here is to calculate the correct indices for each element during simulation:</p>
<p><a name="imp:lec4:MassSpringEnergyHess"></a>
<strong>Implementation 4.6.8 (Computing Hessians, MassSpringEnergy.cu).</strong></p>
<pre><code class="language-cpp">template &lt;typename T, int dim&gt;
const DeviceTripletMatrix&lt;T, 1&gt; &amp;MassSpringEnergy&lt;T, dim&gt;::hess()
{
	auto &amp;device_x = pimpl_-&gt;device_x;
	auto &amp;device_e = pimpl_-&gt;device_e;
	auto &amp;device_l2 = pimpl_-&gt;device_l2;
	auto &amp;device_k = pimpl_-&gt;device_k;
	auto N = device_e.size() / 2;
	auto &amp;device_hess = pimpl_-&gt;device_hess;
	auto device_hess_row_idx = device_hess.row_indices();
	auto device_hess_col_idx = device_hess.col_indices();
	auto device_hess_val = device_hess.values();
	device_hess_val.fill(0);
	ParallelFor(256).apply(N, [device_x = device_x.cviewer(), device_e = device_e.cviewer(), device_l2 = device_l2.cviewer(), device_k = device_k.cviewer(), device_hess_val = device_hess_val.viewer(), device_hess_row_idx = device_hess_row_idx.viewer(), device_hess_col_idx = device_hess_col_idx.viewer(), N] __device__(int i) mutable
						   {
		int idx[2] = {device_e(2 * i), device_e(2 * i + 1)}; // First node index
		T diff = 0;
		T diffi[dim];
		for (int d = 0; d &lt; dim; d++)
		{
			diffi[d] = device_x(dim * idx[0] + d) - device_x(dim * idx[1] + d);
			diff += diffi[d] * diffi[d];
		}
		Eigen::Matrix&lt;T, dim, 1&gt; diff_vec(diffi);
		Eigen::Matrix&lt;T, dim, dim&gt; diff_outer = diff_vec * diff_vec.transpose();
		T scalar = 2 * device_k(i) / device_l2(i);
		Eigen::Matrix&lt;T, dim, dim&gt; H_diff = scalar * (2 * diff_outer + (diff_vec.dot(diff_vec) - device_l2(i)) * Eigen::Matrix&lt;T, dim, dim&gt;::Identity());
		Eigen::Matrix&lt;T, dim * 2, dim * 2&gt; H_block, H_local;
		H_block &lt;&lt; H_diff, -H_diff,
			-H_diff, H_diff;
		make_PSD(H_block, H_local);
		// add to global matrix
		for (int ni = 0; ni &lt; 2; ni++)
			for (int nj = 0; nj &lt; 2; nj++)
			{
				int indStart = i * 4*dim*dim + (ni * 2 + nj) * dim*dim;
				for (int d1 = 0; d1 &lt; dim; d1++)
					for (int d2 = 0; d2 &lt; dim; d2++){
						device_hess_row_idx(indStart + d1 * dim + d2)= idx[ni] * dim + d1;
						device_hess_col_idx(indStart + d1 * dim + d2)= idx[nj] * dim + d2;
						device_hess_val(indStart + d1 * dim + d2) = H_local(ni * dim + d1, nj * dim + d2);
					}
			} })
		.wait();
	return device_hess;
} // Calculate the Hessian of the energy
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="lec4.5-sim_with_vis.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="lec4.6-summary.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="lec4.5-sim_with_vis.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="lec4.6-summary.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
